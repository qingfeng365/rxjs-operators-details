
<div class="container">
  <h3>debounceTime</h3>
  <div class="panel panel-success">
    <div class="panel-heading">对比分析
      <div class="list-group"></div>
    </div>
  </div>
  <div class="panel panel-info">
    <div class="panel-heading">debounceTime(按时防抖) 说明</div>
    <div class="panel-body">
      <p>签名: debounceTime(dueTime: number, scheduler: Scheduler): Observable</p>
      <p>根据一个选择器函数，舍弃掉在两次输出之间小于指定时间的发出值</p>
      <p>只有在特定的一段时间经过后并且没有发出另一个源值，才从源 Observable 中发出一个值</p>
      <p>就像是delay, 但是只通过每次大量发送中的最新值</p>
      <p>此操作符在诸如预先知道用户的输入频率的场景下很受欢迎</p>
      <p>debounceTime 延时发送源 Observable 发送的值,但是会丢弃正在排队的发送如果源 Observable 又发出新值。 该操作符会追踪源 Observable 的最新值, 并且发出它当且仅当在 dueTime 时间段内 没有发送行为。 如果新的值在dueTime静默时间段出现, 之前的值会被丢弃并且不会在输出 Observable 中发出</p>
      <p>这是一个控制发送频率的操作符，因为不可能在任何时间窗口的持续时间(dueTime)内发出一个以上的值，同样也是一个延时类操作符，因为输出 并不一定发生在同一时间，正如源 Observable 上发生的</p>
      <p>dueTime: 在发送最新的源值之前需要等待的以毫秒为单位(或者由可选的scheduler 提供的时间单位)的时间间隔</p>
      <p>debounceTime 是 debounce 的语法糖</p><img src="../assets/images/debounceTime.png" class="img-responsive center-block"/>
      <pre class="pre-scrollable">弹珠图解析:</pre>
    </div>
  </div>
  <div class="panel panel-info">
    <div class="panel-heading">示例1: 弹珠图模拟示例</div>
    <div class="panel-body">
      <pre [innerHtml]="demo1Info" class="pre-scrollable"></pre>
      <p>
        <button type="button" [disabled]="isRuning" (click)="runDemo1zip();$event.stopPropagation()" class="btn btn-primary">运行</button>
      </p>
    </div>
  </div>
  <div class="panel panel-info">
    <div class="panel-heading">示例2:搜索框</div>
    <div class="panel-body">
      <p>
        <input type="text" [formControl]="searchCrtl" placeholder="请输入搜索内容..."/>
      </p>
      <div class="alert alert-info">正在搜索: {{searchWord}}</div>
      <pre [innerHtml]="demo2Info" class="pre-scrollable"></pre>
    </div>
  </div>
</div>